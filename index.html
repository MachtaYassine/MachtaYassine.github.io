<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Yassine Machta - Draft</title>
<style>
        body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        background-color: rgb(0, 0, 0);
    }

    .grid-container {
        display: grid;
        grid-gap: 0px; /* Gap between grid items */
        padding: 0; /* Remove padding */
        width: 100%; /* Take the full width of the viewport */
        height: 100%; /* Take the full height of the viewport */
        overflow: hidden; /* Prevent overflow */
        position: relative; /* Position relative for absolutely positioned children */
        grid-template-columns:  repeat(var(--columns), 1fr) ;
        grid-template-rows:  repeat(var(--rows), 1fr)  ;
    }

    .grid-item {
    background-color: #000000; 
    text-align: center; /* Center align text */
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative; /* Set position to relative */
    border: 0px solid transparent; /* Add a thin border */
    }

    .circle {
        width: 100%;
        height: 100%;
        fill: #5e0202;
    }

    .coordinates {
        position: absolute; /* Position the text relative to the grid item */
        bottom: 5px; /* Adjust the position from bottom */
        color: white; /* Text color */
        font-size: 10px; /* Text font size */
    }

</style>
</head>
<body>

<div class="grid-container" id="gridContainer">
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script>
    var numColumns, numRows;
    var itemWidth = 70; // Set initial width of grid items
    var itemHeight = 70; // Set initial height of grid items
    var gridGap = 0; // Gap between grid items
    let gridContainer = document.getElementById('gridContainer');
    // Calculate the number of columns and rows based on viewport size and grid item size
    numColumns = Math.floor((window.innerWidth - 0) / (itemWidth + gridGap));
    numRows = Math.floor((window.innerHeight - 0) / (itemHeight + gridGap));
    var numItems = numColumns * numRows; // Calculate total number of items
    console.log("numColumns: ", numColumns, "numRows: ", numRows, "numItems: ", numItems);
    gridContainer.innerHTML = ''; // Clear previous items
    gridContainer.style.setProperty("--columns", numColumns);
    gridContainer.style.setProperty("--rows", numRows);
    console.log("gridContainer grid-template-value is ", gridContainer.style);
    var svgLines = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svgLines.style.position = 'absolute';
    svgLines.setAttribute("width", window.innerWidth);
    svgLines.setAttribute("height", window.innerHeight);
    svgLines.setAttribute("fill", "transparent");
    rect= document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("x", 0);
    rect.setAttribute("y", 0);
    rect.setAttribute("width", window.innerWidth);
    rect.setAttribute("height", window.innerHeight);
    rect.setAttribute("border", "white");
    rect.setAttribute("fill", "transparent");
    // svgLines.appendChild(rect);
    var drawnLines = {}; // Object to keep track of drawn lines


    // Function to create SVG circle
    function createCircle() {
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("class", "circle");
        svg.setAttribute("viewBox", "0 0 100 100");
        var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        offset_x = 50 + (Math.random() * 50) - 25;
        offset_y = 50 + (Math.random() * 50) - 25;
        circle.setAttribute("cx", offset_x);
        circle.setAttribute("cy", offset_y);
        circle.setAttribute("r", "1");
        svg.appendChild(circle);
        return svg;
    }

    // Function to draw lines between neighboring circle centers
    function drawLines() {
        var gridContainer = document.getElementById('gridContainer');
        var svgLines = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svgLines.style.position = 'absolute';
        svgLines.setAttribute("width", window.innerWidth);
        svgLines.setAttribute("height", window.innerHeight);

        var drawnLines = {}; // Object to keep track of drawn lines

        for (var y = 1; y <= numRows; y++) {
            for (var x = 1; x <= numColumns; x++) {
                var gridItem = getGridItem(x, y);
                var circle1 = gridItem.querySelector('.circle circle');
                var circle1Rect = circle1.getBoundingClientRect();

                for (var j = y - 1; j <= y + 1; j++) {
                    for (var i = x - 1; i <= x + 1; i++) {
                        // Skip the current cell and cells out of bounds
                        if ((i === x && j === y) || i < 1 || i > numColumns || j < 1 || j > numRows)
                            continue;

                        // Sort the coordinates to avoid duplicates
                        var coordinates = [[x, y], [i, j]].sort();

                        // Check if the line between the two points has already been drawn
                        if (!drawnLines[coordinates.toString()]) {
                            var grid2Item = getGridItem(i, j);
                            var circle2 = grid2Item.querySelector('.circle circle');
                            var circle2Rect = circle2.getBoundingClientRect();

                            // Calculate the center of circle1 and circle2
                            var cx1 = circle1Rect.left + circle1Rect.width / 2;
                            var cy1 = circle1Rect.top + circle1Rect.height / 2;
                            var cx2 = circle2Rect.left + circle2Rect.width / 2;
                            var cy2 = circle2Rect.top + circle2Rect.height / 2;

                            // Create line between the centers of circle1 and circle2
                            var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            line.setAttribute("x1", cx1);
                            line.setAttribute("y1", cy1);
                            line.setAttribute("x2", cx1);
                            line.setAttribute("y2", cy1);
                            line.setAttribute("stroke", "#790e0e");
                            svgLines.appendChild(line);

                            // Animate the propagation of lines
                            anime({
                                targets: line,
                                x2: cx2,
                                y2: cy2,
                                duration: 1000,
                                easing: 'linear',
                                delay: Math.random() * 1000
                            });

                            // Mark the line as drawn
                            drawnLines[coordinates.toString()] = true;
                        }
                    }
                }
            }
        }

        gridContainer.appendChild(svgLines);
    }

    // JavaScript to dynamically create grid items
    function createGridItems() {
        

        for (var y = 0; y < numRows; y++) {
            for (var x = 0; x < numColumns; x++) {
                var gridItem = document.createElement('div');
                gridItem.className = 'grid-item';
                if ( x==0 || x==numColumns-1) {
                    // gridItem.style.width = gridItem.style.width/2;
                    // gridItem.style.height = gridItem.style.height/2;
                }
                

                // // Create circle
                // var circle = createCircle();
                // gridItem.appendChild(circle);

                // Position grid item
                gridItem.style.gridColumn = x + 1; // Add 1 to convert to 1-based indexing
                gridItem.style.gridRow = y + 1;
                
                //coordinates = document.createElement('div');
                //coordinates.className = 'coordinates';
                //coordinates.innerHTML = (x + 1) + ', ' + (y + 1);
                //gridItem.appendChild(coordinates);

                // Append grid item to container
                gridContainer.appendChild(gridItem);
                // console.log("gridContainer grid-template-value is ", gridContainer.style);
            }
        }
    }

    function propagate_to_next(x, y) {
        // Define the animation parameters
        const circle_scale = 0.01;
        const circle_color = '#5e0202';
        distance_from_initial_random_points= Math.abs(x-randomX) + Math.abs(y-randomY);
        const circle_animation_duration = Math.max(50,200 - distance_from_initial_random_points*17);
        const circle_animation_delay = 4*circle_animation_duration;
        const gridItem_animation_delay = 4*circle_animation_duration;
        function createLineBetweenCircles(x1, y1, x2, y2,propagate_to_next_bool=true) {
            // Get the circles and their bounding rects
            const circle1 = getGridItem(x1, y1).querySelector('.circle circle');
            const circle2 = getGridItem(x2, y2).querySelector('.circle circle');
            const circle1Rect = circle1.getBoundingClientRect();
            const circle2Rect = circle2.getBoundingClientRect();

            // Calculate the center coordinates of the circles
            const cx1 = circle1Rect.left + circle1Rect.width / 2;
            const cy1 = circle1Rect.top + circle1Rect.height / 2;
            const cx2 = circle2Rect.left + circle2Rect.width / 2;
            const cy2 = circle2Rect.top + circle2Rect.height / 2;

            // Create the SVG line element
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", cx1);
            line.setAttribute("y1", cy1);
            line.setAttribute("x2", cx1);
            line.setAttribute("y2", cy1);
            line.setAttribute("stroke", "#5e0202");

            svgLines.appendChild(line);
            //animate the line
            anime({
                targets: line,
                x2: cx2,
                y2: cy2,
                duration: circle_animation_duration+ Math.random()*3*circle_animation_duration -(3*circle_animation_duration/2),
                easing: 'linear',
                complete: function () {
                    if (propagate_to_next_bool) {
                        // Once the line animation is complete, create and animate the circle
                    // console.log("x2: ", x2, "y2: ", y2);
                    var gridItem = getGridItem(x2, y2);
                    var circle = gridItem.querySelector('.circle');
                    
                    anime({
                        targets: circle.querySelector('circle'),
                        r: '20',
                        duration: circle_animation_duration,
                        easing: 'easeInOutSine',
                        complete: function () {
                            // After the circle animation is complete, propagate to the next point
                            propagate_to_next(x2, y2);
                            // if (y2!=numRows) {
                                anime({
                                targets: circle.querySelector('circle'),
                                r: '150',
                                duration: circle_animation_duration,
                                easing: 'easeInOutBack',
                                delay: 1000,
                                duration: 1000,
                            });
                            // }
                            
                        }
                    });
                    }
                    
                }
            });
        }

        
        // Define a function to handle direction (horizontal, vertical, and diagonal)
        function handle_direction(x, y, dx, dy) {
            const newX = x + dx;
            const newY = y + dy;

            // Skip cells out of bounds or already filled
            if (newX < 1 || newX > numColumns || newY < 1 || newY > numRows || !getGridItem(newX, newY) ) {
                return;
            }
            if (getGridItem(newX, newY).querySelector('.circle') != null) {
            createLineBetweenCircles(x, y, newX, newY,propagate_to_next_bool=false);
            return;
            }

            // console.log("   propagating to ", newX, newY);

            // Create circle and animate its expansion
            var gridItem = getGridItem(newX, newY);
            var circle = createCircle();
            gridItem.appendChild(circle);
            //create line between the two points
            createLineBetweenCircles(x, y, newX, newY);
            

            

            

            
        }

        // Handle horizontal, vertical, and diagonal directions
        handle_direction(x, y, 1, 0); // Right
        handle_direction(x, y, -1, 0); // Left
        handle_direction(x, y, 0, 1); // Down
        handle_direction(x, y, 0, -1); // Up
        handle_direction(x, y, 1, 1); // Down-Right
        handle_direction(x, y, -1, 1); // Down-Left
        handle_direction(x, y, 1, -1); // Up-Right
        handle_direction(x, y, -1, -1); // Up-Left
    }




    // Function to expand the grid
    function ExpandGrid(){
        //Expands the circles to fill the grid
        for (var y = 1; y < numRows; y++) {
            for (var x = 1; x <= numColumns; x++) {
                var gridItem = getGridItem(x, y);
                var circle = createCircle();
                gridItem.appendChild(circle);
                var circle = gridItem.querySelector('.circle circle');

                // Expand circle animation
                anime({
                    targets: circle,
                    r: '100',
                    duration: 1000,
                    easing: 'easeInOutSine',
                    complete: function() {
                        
                    }
                });
            }
        }
    }





    // Initial call to create grid items
    createGridItems();

    // Update grid items and draw lines on window resize
    window.addEventListener('resize', function () {
        pass
    });

    // Function to get grid item by coordinates
    function getGridItem(x, y) {
        return document.querySelector('.grid-item:nth-child(' + ((y - 1) * numColumns + x) + ')');
    }

    // Function to animate circle expansion
    function animateCircleExpansion(randomX, randomY) {
        console.log("randomX: ", randomX, "randomY: ", randomY);
        var gridItem = getGridItem(randomX, randomY);
        var circle = createCircle();
        gridItem.appendChild(circle);
        var circle = gridItem.querySelector('.circle circle');

        // Expand circle animation
        anime({
            targets: circle,
            r: '20',
            duration: 1000,
            easing: 'easeInOutSine',
            complete: function() {
                propagate_to_next(randomX,randomY);
                // if (randomY!=numRows) {
                    anime({
                    targets: circle,
                    r: '150',
                    easing: 'easeInOutSine',
                    delay: 1000,
                    duration: 250,
                });
            }
        });}

        

    var randomX = Math.floor(Math.random() * numColumns) + 1;
    var randomY = Math.floor(Math.random() * numRows) + 1;
    function launch_loading_anim() {
        
        animateCircleExpansion(randomX, randomY);
        gridContainer.appendChild(svgLines);

        // ExpandGrid();
        
    }

    // Example usage:
    window.addEventListener('load', function () {
        launch_loading_anim();
    });
</script>

</body>
</html>
