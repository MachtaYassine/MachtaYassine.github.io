<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Adaptive Grid Layout</title>
<style>
        body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        background-color: black;
    }

    .grid-container {
        display: grid;
        grid-gap: 0px; /* Gap between grid items */
        padding: 0; /* Remove padding */
        width: 100%; /* Take the full width of the viewport */
        height: 100%; /* Take the full height of the viewport */
        overflow: hidden; /* Prevent overflow */
        position: relative; /* Position relative for absolutely positioned children */
    }

    .grid-item {
        background-color: #ffffff; 
        text-align: center; /* Center align text */
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative; /* Set position to relative */
        border: 0; /* Remove border */
    }

    .circle {
        width: 100%;
        height: 100%;
        fill: #790e0e;
    }

    .coordinates {
        position: absolute; /* Position the text relative to the grid item */
        bottom: 5px; /* Adjust the position from bottom */
        color: white; /* Text color */
        font-size: 10px; /* Text font size */
    }

</style>
</head>
<body>

<div class="grid-container" id="gridContainer">
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script>
    var numColumns, numRows;
    var itemWidth = 70; // Set initial width of grid items
    var itemHeight = 70; // Set initial height of grid items
    var gridGap = 0; // Gap between grid items
    let gridContainer = document.getElementById('gridContainer');
    // Calculate the number of columns and rows based on viewport size and grid item size
    numColumns = Math.floor((window.innerWidth - 0) / (itemWidth + gridGap));
    numRows = Math.floor((window.innerHeight - 0) / (itemHeight + gridGap));
    var numItems = numColumns * numRows; // Calculate total number of items
    gridContainer.innerHTML = ''; // Clear previous items
    var svgLines = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svgLines.style.position = 'absolute';
    svgLines.setAttribute("width", window.innerWidth);
    svgLines.setAttribute("height", window.innerHeight);
    svgLines.setAttribute("fill", "transparent");
    rect= document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("x", 0);
    rect.setAttribute("y", 0);
    rect.setAttribute("width", window.innerWidth);
    rect.setAttribute("height", window.innerHeight);
    rect.setAttribute("border", "white");
    rect.setAttribute("fill", "transparent");
    // svgLines.appendChild(rect);
    var drawnLines = {}; // Object to keep track of drawn lines


    // Function to create SVG circle
    function createCircle() {
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("class", "circle");
        svg.setAttribute("viewBox", "0 0 100 100");
        var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        offset_x = 50 + (Math.random() * 50) - 25;
        offset_y = 50 + (Math.random() * 50) - 25;
        circle.setAttribute("cx", offset_x);
        circle.setAttribute("cy", offset_y);
        circle.setAttribute("r", "1");
        svg.appendChild(circle);
        return svg;
    }

    // Function to draw lines between neighboring circle centers
    function drawLines() {
        var gridContainer = document.getElementById('gridContainer');
        var svgLines = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svgLines.style.position = 'absolute';
        svgLines.setAttribute("width", window.innerWidth);
        svgLines.setAttribute("height", window.innerHeight);

        var drawnLines = {}; // Object to keep track of drawn lines

        for (var y = 1; y <= numRows; y++) {
            for (var x = 1; x <= numColumns; x++) {
                var gridItem = getGridItem(x, y);
                var circle1 = gridItem.querySelector('.circle circle');
                var circle1Rect = circle1.getBoundingClientRect();

                for (var j = y - 1; j <= y + 1; j++) {
                    for (var i = x - 1; i <= x + 1; i++) {
                        // Skip the current cell and cells out of bounds
                        if ((i === x && j === y) || i < 1 || i > numColumns || j < 1 || j > numRows)
                            continue;

                        // Sort the coordinates to avoid duplicates
                        var coordinates = [[x, y], [i, j]].sort();

                        // Check if the line between the two points has already been drawn
                        if (!drawnLines[coordinates.toString()]) {
                            var grid2Item = getGridItem(i, j);
                            var circle2 = grid2Item.querySelector('.circle circle');
                            var circle2Rect = circle2.getBoundingClientRect();

                            // Calculate the center of circle1 and circle2
                            var cx1 = circle1Rect.left + circle1Rect.width / 2;
                            var cy1 = circle1Rect.top + circle1Rect.height / 2;
                            var cx2 = circle2Rect.left + circle2Rect.width / 2;
                            var cy2 = circle2Rect.top + circle2Rect.height / 2;

                            // Create line between the centers of circle1 and circle2
                            var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            line.setAttribute("x1", cx1);
                            line.setAttribute("y1", cy1);
                            line.setAttribute("x2", cx1);
                            line.setAttribute("y2", cy1);
                            line.setAttribute("stroke", "#790e0e");
                            svgLines.appendChild(line);

                            // Animate the propagation of lines
                            anime({
                                targets: line,
                                x2: cx2,
                                y2: cy2,
                                duration: 1000,
                                easing: 'linear',
                                delay: Math.random() * 1000
                            });

                            // Mark the line as drawn
                            drawnLines[coordinates.toString()] = true;
                        }
                    }
                }
            }
        }

        gridContainer.appendChild(svgLines);
    }

    // JavaScript to dynamically create grid items
    function createGridItems() {
        

        for (var y = 0; y < numRows; y++) {
            for (var x = 0; x < numColumns; x++) {
                var gridItem = document.createElement('div');
                gridItem.className = 'grid-item';
                gridItem.style.width = itemWidth + 'px';
                gridItem.style.height = itemHeight + 'px';

                // // Create circle
                // var circle = createCircle();
                // gridItem.appendChild(circle);

                // Position grid item
                gridItem.style.gridColumn = x + 1; // Add 1 to convert to 1-based indexing
                gridItem.style.gridRow = y + 1;
                
                // coordinates = document.createElement('div');
                // coordinates.className = 'coordinates';
                // coordinates.innerHTML = (x + 1) + ', ' + (y + 1);
                // gridItem.appendChild(coordinates);

                // Append grid item to container
                gridContainer.appendChild(gridItem);
            }
        }
    }

    function propagate_to_next(x, y) {
        // Define the animation parameters
        const circle_scale = 0.01;
        const circle_color = "red";
        distance_from_initial_random_points= Math.abs(x-randomX) + Math.abs(y-randomY);
        const circle_animation_duration = Math.max(10,300 - distance_from_initial_random_points*10);
        const circle_animation_delay = circle_animation_duration;
        const gridItem_animation_delay = 2*circle_animation_duration;
        function createLineBetweenCircles(x1, y1, x2, y2) {
            // Get the circles and their bounding rects
            const circle1 = getGridItem(x1, y1).querySelector('.circle circle');
            const circle2 = getGridItem(x2, y2).querySelector('.circle circle');
            const circle1Rect = circle1.getBoundingClientRect();
            const circle2Rect = circle2.getBoundingClientRect();

            // Calculate the center coordinates of the circles
            const cx1 = circle1Rect.left + circle1Rect.width / 2;
            const cy1 = circle1Rect.top + circle1Rect.height / 2;
            const cx2 = circle2Rect.left + circle2Rect.width / 2;
            const cy2 = circle2Rect.top + circle2Rect.height / 2;

            // Create the SVG line element
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", cx1);
            line.setAttribute("y1", cy1);
            line.setAttribute("x2", cx1);
            line.setAttribute("y2", cy1);
            line.setAttribute("stroke", "#790e0e");

            svgLines.appendChild(line);
            //animate the line
            anime({
                targets: line,
                x2: cx2,
                y2: cy2,
                duration: circle_animation_duration,
                easing: 'linear',
            });
        }

        
        // Define a function to handle direction (horizontal, vertical, and diagonal)
        function handle_direction(x, y, dx, dy) {
            const newX = x + dx;
            const newY = y + dy;

            // Skip cells out of bounds or already filled
            if (newX < 1 || newX > numColumns || newY < 1 || newY > numRows || !getGridItem(newX, newY) ) {
                return;
            }
            if (getGridItem(newX, newY).querySelector('.circle') != null) {
            createLineBetweenCircles(x, y, newX, newY);
            return;
            }

            // console.log("   propagating to ", newX, newY);

            // Create circle and animate its expansion
            var gridItem = getGridItem(newX, newY);
            var circle = createCircle();
            gridItem.appendChild(circle);
            //create line between the two points
            createLineBetweenCircles(x, y, newX, newY);
            

            anime({
                targets: circle.querySelector('circle'),
                r: '10',
                duration: circle_animation_duration,
                easing: 'easeInOutSine',
                complete: function () {
                    propagate_to_next(newX, newY);
                }
            });

            // anime({
            //     targets: circle.querySelector('circle'),
            //     r: '75',
            //     duration: circle_animation_duration,
            //     delay: circle_animation_delay,
            //     easing: 'easeInOutSine'
            // });

            // anime({
            //     targets: gridItem,
            //     backgroundColor: '#790e0e',
            //     delay: gridItem_animation_delay,
            // });
        }

        // Handle horizontal, vertical, and diagonal directions
        handle_direction(x, y, 1, 0); // Right
        handle_direction(x, y, -1, 0); // Left
        handle_direction(x, y, 0, 1); // Down
        handle_direction(x, y, 0, -1); // Up
        handle_direction(x, y, 1, 1); // Down-Right
        handle_direction(x, y, -1, 1); // Down-Left
        handle_direction(x, y, 1, -1); // Up-Right
        handle_direction(x, y, -1, -1); // Up-Left
    }










    // Initial call to create grid items
    createGridItems();

    // Update grid items and draw lines on window resize
    window.addEventListener('resize', function () {
        createGridItems();
        drawLines();
    });

    // Function to get grid item by coordinates
    function getGridItem(x, y) {
        return document.querySelector('.grid-item:nth-child(' + ((y - 1) * numColumns + x) + ')');
    }

    // Function to animate circle expansion
    function animateCircleExpansion(randomX, randomY) {
        console.log("randomX: ", randomX, "randomY: ", randomY);
        var gridItem = getGridItem(randomX, randomY);
        var circle = createCircle();
        gridItem.appendChild(circle);
        var circle = gridItem.querySelector('.circle circle');

        // Expand circle animation
        anime({
            targets: circle,
            r: '60',
            duration: 1000,
            easing: 'easeInOutSine',
            complete: function() {
                propagate_to_next(randomX,randomY);
            }
        });

        anime({
            targets: circle,
            r: '75',
            duration: 1000,
            delay: 1000,
            easing: 'easeInOutSine'
        });

        anime({
            targets: gridItem,
            backgroundColor: '#790e0e',
            delay: 2000,
        });
    }

    var randomX = Math.floor(Math.random() * numColumns) + 1;
    var randomY = Math.floor(Math.random() * numRows) + 1;
    function launch_loading_anim() {
        
        animateCircleExpansion(randomX, randomY);
        gridContainer.appendChild(svgLines);
        // drawLines(); // Draw lines after circle animation
    }

    // Example usage:
    window.addEventListener('load', function () {
        launch_loading_anim();
    });
</script>

</body>
</html>
