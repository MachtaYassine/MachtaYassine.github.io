<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Yassine Machta - Draft</title>
<style>
        body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        background-color: rgb(0, 0, 0);
        border: #ffffff;
        overflow-x: hidden;
    }

    .grid-container {
        display: grid;
        grid-gap: 0px; /* Gap between grid items */
        padding: 0; /* Remove padding */
        width: 100%; /* Take the full width of the viewport */
        height: 100%; /* Take the full height of the viewport */
        overflow: hidden; /* Prevent overflow */
        position: relative; /* Position relative for absolutely positioned children */
        grid-template-columns:  repeat(var(--columns), 1fr) ;
        grid-template-rows:  repeat(var(--rows), 1fr)  ;
    }

    .grid-item {
    background-color: #000000; 
    text-align: center; /* Center align text */
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative; /* Set position to relative */
    border: 0px solid transparent; /* Add a thin border */
    }

    .circle {
        width: 100%;
        height: 100%;
        fill: #141414;
    }

    .coordinates {
        position: absolute; /* Position the text relative to the grid item */
        bottom: 5px; /* Adjust the position from bottom */
        color: white; /* Text color */
        font-size: 10px; /* Text font size */
    }
    /* Style for the header container */
    #headerContainer {
        position: absolute;
        top: 2.5%; /* 2% from the top of the viewport */
        left: 10%; /* 2% from the left of the viewport */
        display: flex;
        align-items: center;
        color: #F89D13; /* Set color to #F89D13 */
        z-index: 2; /* Ensure it's on top */
        font-weight: 200;
        font-size: 2em;
        overflow: hidden;
    }

    #imageContainer {
        position: absolute;
        top: 15%; /* 10% from the top of the viewport */
        right: 5%; /* 10% from the right of the viewport */
        width:fit-content; /* 30% of the viewport width */
        height: 70%; /* 70% of the viewport height */
        border: 5px solid #F89D13;
        display: flex; /* Use flexbox */
        align-items: center; 
        justify-content: center; 
        overflow: hidden; 
        z-index: 2; 
    }

    #profilePicture {
    width: auto; /* Auto width */
    height: 100%; /* 100% height */
    object-fit: cover; /* Cover the container while maintaining aspect ratio */
    z-index: 2; /* Ensure it's on top */
    }


    #topBarContainer {
        position: fixed;
        top: -100px;
        left: 0;
        width: 100%; /* Take the full width */
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: white;
        background-color: rgba(0, 0, 0, 0.8); /* Set background color with transparency */
        z-index: 2; /* Ensure it's on top */
        transition: top 0.5s ease;
    }

    /* Bottom bar container */
    #bottomBarContainer {
        position: fixed;
        bottom: -100px;
        left: 0;
        width: 100%; /* Take the full width */
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: white;
        background-color: rgba(0, 0, 0, 0); /* Set background color with transparency */
        z-index: 2; /* Ensure it's on top */
        transition: bottom 0.5s ease
    }
    #bottomBarContainer p {
        margin: 0; /* Remove default margin */
        font-weight: 200;
        font-size: 1.1em;
        opacity: 0.5; /* Set opacity for subtle appearance */
        text-align: center;
        flex-grow: 1;
    }
    #resumeButton {
    display: inline-block;
    padding: 10px 20px;
    background-color: #F89D13; /* Button background color */
    color: #ffffff; /* Button text color */
    text-decoration: none;
    border-radius: 5px;
}

    .button-content {
        display: flex;
        align-items: center;
        gap: 5px; /* Adjust spacing between icon and text */
    }

    #resumeButton:hover lord-icon {
        animation: play 1s infinite; /* Add animation on hover */
    }



    /* Style for the introduction paragraph */
    #introduction {
        position: absolute;
        top: 140px;
        left: 15px;
        width: 65%; /* Adjust width */
        color: white; /* Set color to white */
        z-index: 2; /* Ensure it's on top */
        font-weight: 200;
        font-size: 1.1em;
    }
    </style>
</head>
<link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="assets/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="assets/favicon-16x16.png">
<body>

<!-- Header container -->
<div id="headerContainer" style="opacity: 0; transform: translateX(-100%);">
    <h1>Yassine Machta</h1> <!-- Your name -->
</div>

<!-- Image container -->
<div id="imageContainer" style="opacity: 0; transform: translateX(100%);">
    <!-- Add your picture here -->
    <img src="assets/photo_ensae.jpg" alt="Your Picture" id="profilePicture">
</div>

<!-- Bar container -->
<div id="topBarContainer">
    <!-- Resume button -->
    <a id="resumeButton" href="path/to/your/resume.pdf" target="_blank" onmouseover="startAnimation()" onmouseout="stopAnimation()">
    <div class="button-content" >
        <lord-icon
            src="assets/resume.json"
            colors="primary:#ffffff"
            style="width:25px;height:25px">
        </lord-icon>
        <span>Resume</span>
    </div>
</a>

</div>

<!-- Introduction paragraph -->
<div id="introduction" style="opacity: 0; transform: translateX(-100%);">
    <h2>Website Presentation</h2>
    <p>
        Hi, this page is part of my personal endeavor to try and learn HTML/CSS and JavaScript Frameworks.  <br>
        <br>
        As a wannabe aspiring researcher I will also be using it to introduce myself, present my interests, and showcase my work. <br>
        <span style="color: #F89D13; font-weight: bold;">This page is incomplete.</span> Feel free to come back in the future to see the progress. Doesn't look like much now, but it's honest work!
    </p>
    

    <h2>About me</h2>
    I am currenty on a gap year between my 2nd and 3rd year of the ENSAE Paris. (Masters 1 and 2). <br>
    I am interested in improving my skills and knowledge in programming, but also proabiblity and statistics. <br>
    If you wish to know more about me, feel free to take a look at my resume attached to the bar above. <br>
    <h2>Research Statement</h2>

    Right now I am attempting to get acquainted with as many research fields as possible in order to better narrow my focus. <br>
    My interests are : <br>
    - AI in Healthcare  <br>
    - Visual Computing  <br>
    - Agent decision making, in Robotics but preferrably Game AI <br>
    - Game development (Small indie project on my side where I try to experiment with my above interest) <br>
    - Finance Research <br>
    - Recommendation Systems <br>
</div>


<!-- Bottom bar container -->
<div id="bottomBarContainer">
    <!-- Copyright notice -->
    <p>&copy; 2024 Yassine Machta. All rights reserved. Icons are from lordicon.com</p>
</div>
<!-- Grid container for animations -->
<div class="grid-container" id="gridContainer"></div>

<script src="https://cdn.lordicon.com/lordicon.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
    
    function startAnimation() {
        var icon = document.querySelector('.button-content lord-icon');
        // icon.setAttribute('loop', 'true');
        icon.playerInstance.play();
        icon.playerInstance.direction *= -1;
        console.log('start animation')
    }

    function stopAnimation() {
        var icon = document.querySelector('.button-content lord-icon');
        icon.setAttribute('loop', 'false');
        icon.playerInstance.direction *= -1;
        icon.playerInstance.play();
        
    }

    var numColumns, numRows;
    var itemWidth = 70; // Set initial width of grid items
    var itemHeight = 70; // Set initial height of grid items
    var gridGap = 0; // Gap between grid items
    let gridContainer = document.getElementById('gridContainer');
    // Calculate the number of columns and rows based on viewport size and grid item size
    numColumns = Math.floor((window.innerWidth - 0) / (itemWidth + gridGap));
    numRows = Math.floor((window.innerHeight - 0) / (itemHeight + gridGap));
    var numItems = numColumns * numRows; // Calculate total number of items
    console.log("numColumns: ", numColumns, "numRows: ", numRows, "numItems: ", numItems);
    gridContainer.innerHTML = ''; // Clear previous items
    gridContainer.style.setProperty("--columns", numColumns);
    gridContainer.style.setProperty("--rows", numRows);
    console.log("gridContainer grid-template-value is ", gridContainer.style);
    var svgLines = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svgLines.style.position = 'absolute';
    svgLines.setAttribute("width", window.innerWidth);
    svgLines.setAttribute("height", window.innerHeight);
    svgLines.setAttribute("fill", "transparent");
    rect= document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect.setAttribute("x", 0);
    rect.setAttribute("y", 0);
    rect.setAttribute("width", window.innerWidth);
    rect.setAttribute("height", window.innerHeight);
    rect.setAttribute("border", "white");
    rect.setAttribute("fill", "transparent");
    // svgLines.appendChild(rect);
    var drawnLines = {}; // Object to keep track of drawn lines


    // Function to create SVG circle
    function createCircle() {
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("class", "circle");
        svg.setAttribute("viewBox", "0 0 100 100");
        var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        offset_x = 50 + (Math.random() * 50) - 25;
        offset_y = 50 + (Math.random() * 50) - 25;
        circle.setAttribute("cx", offset_x);
        circle.setAttribute("cy", offset_y);
        circle.setAttribute("r", "1.5");
        svg.appendChild(circle);
        return svg;
    }

    // Function to draw lines between neighboring circle centers
    function drawLines() {
        var gridContainer = document.getElementById('gridContainer');
        var svgLines = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svgLines.style.position = 'absolute';
        svgLines.setAttribute("width", window.innerWidth);
        svgLines.setAttribute("height", window.innerHeight);

        var drawnLines = {}; // Object to keep track of drawn lines

        for (var y = 1; y <= numRows; y++) {
            for (var x = 1; x <= numColumns; x++) {
                var gridItem = getGridItem(x, y);
                var circle1 = gridItem.querySelector('.circle circle');
                var circle1Rect = circle1.getBoundingClientRect();

                for (var j = y - 1; j <= y + 1; j++) {
                    for (var i = x - 1; i <= x + 1; i++) {
                        // Skip the current cell and cells out of bounds
                        if ((i === x && j === y) || i < 1 || i > numColumns || j < 1 || j > numRows)
                            continue;

                        // Sort the coordinates to avoid duplicates
                        var coordinates = [[x, y], [i, j]].sort();

                        // Check if the line between the two points has already been drawn
                        if (!drawnLines[coordinates.toString()]) {
                            var grid2Item = getGridItem(i, j);
                            var circle2 = grid2Item.querySelector('.circle circle');
                            var circle2Rect = circle2.getBoundingClientRect();

                            // Calculate the center of circle1 and circle2
                            var cx1 = circle1Rect.left + circle1Rect.width / 2;
                            var cy1 = circle1Rect.top + circle1Rect.height / 2;
                            var cx2 = circle2Rect.left + circle2Rect.width / 2;
                            var cy2 = circle2Rect.top + circle2Rect.height / 2;

                            // Create line between the centers of circle1 and circle2
                            var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            line.setAttribute("x1", cx1);
                            line.setAttribute("y1", cy1);
                            line.setAttribute("x2", cx1);
                            line.setAttribute("y2", cy1);
                            line.setAttribute("stroke", "#790e0e");
                            svgLines.appendChild(line);

                            // Animate the propagation of lines
                            anime({
                                targets: line,
                                x2: cx2,
                                y2: cy2,
                                duration: 1000,
                                easing: 'linear',
                                delay: Math.random() * 1000
                            });

                            // Mark the line as drawn
                            drawnLines[coordinates.toString()] = true;
                        }
                    }
                }
            }
        }

        gridContainer.appendChild(svgLines);
    }

    // JavaScript to dynamically create grid items
    function createGridItems() {
        

        for (var y = 0; y < numRows; y++) {
            for (var x = 0; x < numColumns; x++) {
                var gridItem = document.createElement('div');
                gridItem.className = 'grid-item';
                if ( x==0 || x==numColumns-1) {
                    // gridItem.style.width = gridItem.style.width/2;
                    // gridItem.style.height = gridItem.style.height/2;
                }
                

                // // Create circle
                // var circle = createCircle();
                // gridItem.appendChild(circle);

                // Position grid item
                gridItem.style.gridColumn = x + 1; // Add 1 to convert to 1-based indexing
                gridItem.style.gridRow = y + 1;
                
                // coordinates = document.createElement('div');
                // coordinates.className = 'coordinates';
                // coordinates.innerHTML = (x + 1) + ', ' + (y + 1);
                // gridItem.appendChild(coordinates);

                // Append grid item to container
                gridContainer.appendChild(gridItem);
                // console.log("gridContainer grid-template-value is ", gridContainer.style);
            }
        }
    }

    function propagate_to_next(x, y) {
        // Define the animation parameters
        const circle_scale = 0.01;
        const circle_color = '#141414';
        distance_from_initial_random_points= 0;
        const circle_animation_duration = Math.max(50,200 - distance_from_initial_random_points*22);
        const circle_animation_delay = 2*circle_animation_duration;
        const gridItem_animation_delay = 2*circle_animation_duration;
        function createLineBetweenCircles(x1, y1, x2, y2,propagate_to_next_bool=true) {
            // Get the circles and their bounding rects
            const circle1 = getGridItem(x1, y1).querySelector('.circle circle');
            const circle2 = getGridItem(x2, y2).querySelector('.circle circle');
            const circle1Rect = circle1.getBoundingClientRect();
            const circle2Rect = circle2.getBoundingClientRect();

            // Calculate the center coordinates of the circles
            const cx1 = circle1Rect.left + circle1Rect.width / 2;
            const cy1 = circle1Rect.top + circle1Rect.height / 2;
            const cx2 = circle2Rect.left + circle2Rect.width / 2;
            const cy2 = circle2Rect.top + circle2Rect.height / 2;

            // Create the SVG line element
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", cx1);
            line.setAttribute("y1", cy1);
            line.setAttribute("x2", cx1);
            line.setAttribute("y2", cy1);
            line.setAttribute("stroke", "#141414");

            svgLines.appendChild(line);
            //animate the line
            anime({
                targets: line,
                x2: cx2,
                y2: cy2,
                duration: circle_animation_duration+ Math.random()*3*circle_animation_duration -(3*circle_animation_duration/2),
                easing: 'linear',
                complete: function () {
                    if (propagate_to_next_bool) {
                        // Once the line animation is complete, create and animate the circle
                    // console.log("x2: ", x2, "y2: ", y2);
                    var gridItem = getGridItem(x2, y2);
                    var circle = gridItem.querySelector('.circle');
                    
                    anime({
                        targets: circle.querySelector('circle'),
                        r: '20',
                        duration: circle_animation_duration,
                        easing: 'easeInOutSine',
                        complete: function () {
                            // After the circle animation is complete, propagate to the next point
                            propagate_to_next(x2, y2);
                            // if (y2!=numRows) {
                                anime({
                                targets: circle.querySelector('circle'),
                                r: '150',
                                duration: circle_animation_duration,
                                easing: 'easeInOutBack',
                                delay: 1000,
                                duration: 500,
                            });
                            // }
                            
                        }
                    });
                    }
                    
                }
            });
        }

        
        // Define a function to handle direction (horizontal, vertical, and diagonal)
        function handle_direction(x, y, dx, dy) {
            const newX = x + dx;
            const newY = y + dy;

            // Skip cells out of bounds or already filled
            if (newX < 1 || newX > numColumns || newY < 1 || newY > numRows || !getGridItem(newX, newY) ) {
                return;
            }
            if (getGridItem(newX, newY).querySelector('.circle') != null) {
            createLineBetweenCircles(x, y, newX, newY,propagate_to_next_bool=false);
            return;
            }

            // console.log("   propagating to ", newX, newY);

            // Create circle and animate its expansion
            var gridItem = getGridItem(newX, newY);
            var circle = createCircle();
            gridItem.appendChild(circle);
            //create line between the two points
            createLineBetweenCircles(x, y, newX, newY);
            

            

            

            
        }

        // Handle horizontal, vertical, and diagonal directions
        handle_direction(x, y, 1, 0); // Right
        handle_direction(x, y, -1, 0); // Left
        handle_direction(x, y, 0, 1); // Down
        handle_direction(x, y, 0, -1); // Up
        handle_direction(x, y, 1, 1); // Down-Right
        handle_direction(x, y, -1, 1); // Down-Left
        handle_direction(x, y, 1, -1); // Up-Right
        handle_direction(x, y, -1, -1); // Up-Left
    }




    // Function to expand the grid
    function ExpandGrid(){
        //Expands the circles to fill the grid
        for (var y = 1; y < numRows; y++) {
            for (var x = 1; x <= numColumns; x++) {
                var gridItem = getGridItem(x, y);
                var circle = createCircle();
                gridItem.appendChild(circle);
                var circle = gridItem.querySelector('.circle circle');

                // Expand circle animation
                anime({
                    targets: circle,
                    r: '100',
                    duration: 1000,
                    easing: 'easeInOutSine',
                    complete: function() {
                        
                    }
                });
            }
        }
    }





    // Initial call to create grid items
    createGridItems();

    // Update grid items and draw lines on window resize
    window.addEventListener('resize', function () {
        pass
    });

    // Function to get grid item by coordinates
    function getGridItem(x, y) {
        return document.querySelector('.grid-item:nth-child(' + ((y - 1) * numColumns + x) + ')');
    }

    // Function to animate circle expansion
    function animateCircleExpansion(randomX, randomY) {
    return new Promise((resolve, reject) => {
        var gridItem = getGridItem(randomX, randomY);
        var circle = createCircle();
        gridItem.appendChild(circle);
        var circle = gridItem.querySelector('.circle circle');

        // Expand circle animation
        anime({
            targets: circle,
            r: '20',
            duration: 500,
            easing: 'easeInOutBack',
            complete: () => {
                propagate_to_next(randomX, randomY);
                anime({
                    targets: circle,
                    r: '150',
                    easing: 'easeInOutBack',
                    delay: 1000,
                    duration: 500,
                    complete: () => resolve("done") // Resolve the promise when animation is complete
                });
            }
        });
        
    });
}




        

    
        function launch_loading_anim(n, callback) {
    var animationsCompleted = 0;
    var target=n;        
    for (var i = 0; i < n; i++) {
        var randomX = Math.floor(Math.random() * numColumns) + 1;
        var randomY = Math.floor(Math.random() * numRows) + 1;
        
        // Check if there is already a circle in the grid item
        if (getGridItem(randomX, randomY).querySelector('.circle') != null) {
            target--;
            continue;
        }
        
        // Animate circle expansion
        // console.log(animateCircleExpansion(randomX, randomY));
        animateCircleExpansion(randomX, randomY).then(() => {
            animationsCompleted++;
            if (animationsCompleted === target && typeof callback === 'function') {
                callback(); // Call the callback function when all animations are completed
            }
        });
    }

    gridContainer.appendChild(svgLines);
}

// Example usage:
window.addEventListener('load', function () {
    launch_loading_anim(10, function() {
        // After the loading animation is complete, animate the header, profile picture, and introduction
        anime.timeline({
            easing: 'easeOutExpo',
            duration: 1000,
            autoplay: true
        })
        .add({
            targets: '#headerContainer',
            opacity: [0, 1],
            translateX: ['-100%', '0']
        })
        .add({
            targets: '#imageContainer',
            opacity: [0, 1],
            translateX: ['100%', '0']
        }, '-=500') // Start this animation 500ms before the previous one ends
        .add({
            targets: '#introduction',
            opacity: [0, 1],
            translateX: ['-100%', '0']
        }, '-=500'); // Start this animation 500ms before the previous one ends

        // Animate the appearance of the top and bottom bars
        setTimeout(function () {
            document.getElementById('topBarContainer').style.top = '0';
        }, 1000);
        setTimeout(function () {
            document.getElementById('bottomBarContainer').style.bottom = '0';
        }, 1000);
    });
});

</script>

</body>
</html>
