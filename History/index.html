<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Adaptive Grid Layout</title>
<style>
    body, html {
        margin: 0;
        padding: 0;
        height: 100%;
        background-color: black;
    }

    .grid-container {
    display: grid;
    grid-gap: 0px; /* Gap between grid items */
    padding: 2px; /* Padding around the grid container */
    width: calc(100% - 6px); /* Take the full width of the viewport minus padding */
    height: calc(100% - 6px); /* Take the full height of the viewport minus padding */
    overflow: hidden; /* Prevent overflow */
    position: relative; /* Position relative for absolutely positioned children */
    }


    .grid-item {
        background-color: #000000; 
        text-align: center; /* Center align text */
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative; /* Set position to relative */
    }

    .circle {
        width: 100%;
        height: 100%;
        fill: #790e0e;
    }

    .coordinates {
        position: absolute; /* Position the text relative to the grid item */
        bottom: 5px; /* Adjust the position from bottom */
        color: white; /* Text color */
        font-size: 10px; /* Text font size */
    }
</style>
</head>
<body>

<div class="grid-container" id="gridContainer">
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script>
    var numColumns, numRows;
    var itemWidth = 40; // Set initial width of grid items
    var itemHeight = 40; // Set initial height of grid items
    var gridGap = 0; // Gap between grid items

    // Function to create SVG circle
    function createCircle() {
        var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("class", "circle");
        svg.setAttribute("viewBox", "0 0 100 100");
        var circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        offset_x=50+(Math.random()*50)-25;
        offset_y=50+(Math.random()*50)-25;
        circle.setAttribute("cx", offset_x);
        circle.setAttribute("cy", offset_y);
        circle.setAttribute("r", "10");
        svg.appendChild(circle);
        return svg;
    }
    

   // Function to draw lines between neighboring circle centers
    function drawLines() {
        var gridContainer = document.getElementById('gridContainer');
        var svgLines = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        // svgLines.setAttribute("viewBox", "0 0 100 100");
        svgLines.style.position = 'absolute';
        // Set width and height attributes
        svgLines.setAttribute("width", window.innerWidth);
        svgLines.setAttribute("height", window.innerHeight);

        // Create rect element to draw border
        var rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");

        // Set rect attributes
        rect.setAttribute("x", "0");
        rect.setAttribute("y", "0");
        svgLines.setAttribute("width", window.innerWidth);
        svgLines.setAttribute("height", window.innerHeight);
        rect.setAttribute("fill", "none"); // Set fill to none for border-only appearance
        rect.setAttribute("stroke", "white"); // Set border color
        rect.setAttribute("stroke-width", "1"); // Set border width

        // Append rect to SVG element
        svgLines.appendChild(rect);

        var drawnLines = {}; // Object to keep track of drawn lines

        for (var y = 1; y <= numRows; y++) {
            for (var x = 1; x <= numColumns; x++) {
                var gridItem = getGridItem(x, y);
                var circle1 = gridItem.querySelector('.circle circle');
                var circle1Rect = circle1.getBoundingClientRect();
                var gridItemRect = gridItem.getBoundingClientRect();
                var gridItemRect = gridItem.getBoundingClientRect();
                // console.log("grid item offset (left,top) = ("+gridItem.offsetLeft+","+gridItem.offsetTop+") (width,height) = ("+gridItem.offsetWidth+","+gridItem.offsetHeight+")");
                // console.log("gridItemRect (left,top) = ("+gridItemRect.left+","+gridItemRect.top+") (width,height) = ("+gridItemRect.width+","+gridItemRect.height+")");
                // console.log("circle1Rect (left,top) = ("+circle1Rect.left+","+circle1Rect.top+") (width,height) = ("+circle1Rect.width+","+circle1Rect.height+")");
                // Loop over neighboring cells within a range of 1
                for (var j = y - 1; j <= y + 1; j++) {
                    for (var i = x - 1; i <= x + 1; i++) {
                        // Skip the current cell and cells out of bounds
                        if ((i === x && j === y) || i < 1 || i > numColumns || j < 1 || j > numRows)
                            continue;

                        // Sort the coordinates to avoid duplicates
                        var coordinates = [ [x, y], [i, j] ].sort();

                        // Check if the line between the two points has already been drawn
                        if (!drawnLines[coordinates.toString()]) {
                            var grid2Item = getGridItem(i, j);
                            var circle2 = grid2Item.querySelector('.circle circle');
                            var circle2Rect = circle2.getBoundingClientRect();
                            var grid2ItemRect = grid2Item.getBoundingClientRect();
                            // Calculate the center of circle1 and circle2
                            var cx1 = circle1Rect.left+circle1Rect.width/2;
                            var cy1 = circle1Rect.top + circle1Rect.height/2;
                            var cx2 = circle2Rect.left+circle2Rect.width/2;
                            var cy2 = circle2Rect.top+circle2Rect.height/2; ;
                            console.log("(x,y) = ("+x+","+y+") (i,j) = ("+i+","+j+")"+" (cx1,cy1) = ("+cx1+","+cy1+") (cx2,cy2) = ("+cx2+","+cy2+")");
                            // Create line between the centers of circle1 and circle2
                            var line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                            line.setAttribute("x1", cx1);
                            line.setAttribute("y1", cy1);
                            line.setAttribute("x2", cx2);
                            line.setAttribute("y2", cy2);
                            line.setAttribute("stroke", "#790e0e");
                            console.log("post line creation (x,y) = ("+x+","+y+") (i,j) = ("+i+","+j+")"+" (cx1,cy1) = ("+cx1+","+cy1+") (cx2,cy2) = ("+cx2+","+cy2+")");
                            // Create text element at the midpoint of the line
                            var text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            text.setAttribute("x", cx1);
                            text.setAttribute("y", cy1);
                            text.setAttribute("fill", "#FFF");
                            text.setAttribute("font-size", "2px"); // Set font size
                            text.textContent ="(x,y) = ("+x+","+y+")"+ "(" + cx1.toFixed(2) + "," + cy1.toFixed(2) + ")";
                            console.log("post text creation (x,y) = ("+x+","+y+") (i,j) = ("+i+","+j+")"+" (cx1,cy1) = ("+cx1+","+cy1+") (cx2,cy2) = ("+cx2+","+cy2+")");
                            var text2 = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            text2.setAttribute("x", cx2);
                            text2.setAttribute("y", cy2);
                            text2.setAttribute("fill", "#FFF");
                            text2.setAttribute("font-size", "2px"); // Set font size
                            text2.textContent ="(i,j) = ("+i+","+j+")"+ "(" + cx2.toFixed(2) + "," + cy2.toFixed(2) + ")";
                            // Append line and text elements to the SVG
                            svgLines.appendChild(line);
                            lineBoundingClientRect = line.getBoundingClientRect();
                            
                            
                            // svgLines.appendChild(text);
                            // svgLines.appendChild(text2);

                            // Mark the line as drawn
                            drawnLines[coordinates.toString()] = true;
                        }
                    }
                }
            }
        }

        gridContainer.appendChild(svgLines);
        svgLines
    }





    // JavaScript to dynamically create grid items
    function createGridItems() {
        let gridContainer = document.getElementById('gridContainer');

        // Calculate the number of columns and rows based on viewport size and grid item size
        numColumns = Math.floor((window.innerWidth - 0) / (itemWidth + gridGap)); 
        numRows = Math.floor((window.innerHeight - 0) / (itemHeight + gridGap));
        var numItems = numColumns * numRows; // Calculate total number of items
        gridContainer.innerHTML = ''; // Clear previous items

        for (var y = 0; y < numRows; y++) {
            for (var x = 0; x < numColumns; x++) {
                var gridItem = document.createElement('div');
                gridItem.className = 'grid-item';
                gridItem.style.width = itemWidth + 'px';
                gridItem.style.height = itemHeight + 'px';

                // Create circle
                var circle = createCircle();
                gridItem.appendChild(circle);

                // Create text for coordinates
                var coordinates = document.createElement('div');
                coordinates.className = 'coordinates';
                coordinates.textContent = '(' + (x + 1) + ', ' + (y + 1) + ')';
                // gridItem.appendChild(coordinates); // Append the text element

                // Position grid item
                gridItem.style.gridColumn = x + 1; // Add 1 to convert to 1-based indexing
                gridItem.style.gridRow = y + 1;
                
                // Append grid item to container
                gridContainer.appendChild(gridItem);
            }
        }
    }

    // Initial call to create grid items
    createGridItems();
    drawLines();
    // Update grid items on window resize
    window.addEventListener('resize', function() {
        createGridItems();
        drawLines();
    });

    // Function to get grid item by coordinates
    function getGridItem(x, y) {
        return document.querySelector('.grid-item:nth-child(' + ((y-1) * numColumns + x ) + ')');
    }

    // Function to animate circle expansion
    function animateCircleExpansion(randomX, randomY) {
        
        var gridItem = getGridItem(randomX, randomY);
        var circle = gridItem.querySelector('.circle circle');

        // Expand circle animation
        anime({
            targets: circle,
            r: '75',
            duration: 600,
            easing: 'easeInOutSine'
        });
        
        anime({
            targets: gridItem,
            backgroundColor: '#790e0e',
            delay:600,
        });
    }

    function launch_loading_anim(){
        var randomX = Math.floor(Math.random() * numColumns) + 1;
        var randomY = Math.floor(Math.random() * numRows) + 1;
        animateCircleExpansion(randomX, randomY);
        
    }
    // Example usage:
    window.addEventListener('resize', function() {
        launch_loading_anim()
    });
    window.addEventListener('load', function() {
        launch_loading_anim()
    });
</script>

</body>
</html>
